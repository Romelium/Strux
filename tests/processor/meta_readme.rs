//! Tests for processing the README.md content itself as input.

use assert_fs::prelude::*;
use predicates::prelude::*;
// Use helpers from the top-level test_common module
use crate::test_common::{run_processor, setup_temp_dir};
// Use the helper from this module's common
use super::common::*;

// This is the exact content of the project's README.md
// It's included here to ensure the test is self-contained and tests against this specific version.
// NOTE: The content below is now a standard string literal. All special characters
// (like `\` and `"`) within the actual README.md content would need to be escaped.
const ACTUAL_README_CONTENT: &str = "# Strux\n\n`strux` is a command-line utility written in Rust that parses specially formatted markdown files to generate directory structures and file contents. It's useful for:\n\n* **Project Bootstrapping:** Quickly create initial project layouts from a template.\n* **Documentation:** Document file structures and provide their content within a single markdown file.\n* **Reproducible Setups:** Define file layouts declaratively.\n\nThe tool reads a markdown file, identifies actions (like creating, appending, prepending, deleting, or moving files) based on specific header formats, and executes these actions relative to a specified output directory.\n\n## Features\n\n* Supports creating files with content defined in code blocks.\n* Supports appending content to existing files (creates if not exists).\n* Supports prepending content to existing files (creates if not exists).\n* Supports deleting files.\n* Supports moving files.\n* Multiple header formats for defining actions (Markdown headers, backticks, internal comments).\n* \"Wrapped\" header format for associating headers with subsequent code blocks or for standalone delete/move actions.\n* Automatic creation of parent directories for created, appended, prepended or moved files.\n* Safety checks to prevent writing or moving files outside the target base directory.\n* Option to force overwriting existing files (for create and move actions).\n* Detailed summary output of actions performed, skipped, or failed.\n* Pre-commit hooks configured for code quality and consistency.\n\n## Installation\n\n### From Source\n\n1. Ensure you have Rust and Cargo installed ([https://rustup.rs/](https://rustup.rs/)).\n2. Clone the repository:\n\n    ```bash\n    git clone https://github.com/romelium/strux.git\n    cd strux\n    ```\n\n3. Build and install the binary:\n\n    ```bash\n    cargo install --path .\n    ```\n\n    This will install the `strux` executable into your Cargo bin directory (usually `~/.cargo/bin/`).\n\n### From Crates.io (Once Published)\n\n```bash\ncargo install strux\n```\n\n### From GitHub Releases\n\nPre-compiled binaries for Linux (x86_64), macOS (x86_64, arm64), and Windows (x86_64) are available on the [GitHub Releases page](https://github.com/romelium/strux/releases). Download the appropriate archive for your system, extract it, and place the `strux` (or `strux.exe`) executable in a directory included in your system's `PATH`.\n\n## Usage\n\n```bash\nstrux [OPTIONS] <MARKDOWN_FILE>\n```\n\n**Arguments:**\n\n* `<MARKDOWN_FILE>`: Path to the input markdown file containing the file structure definitions.\n\n**Options:**\n\n* `-o <DIR>`, `--output-dir <DIR>`: The base directory where files and directories will be created, deleted or moved.\n  * **Default:** `./project-generated`. This path is relative to the **current working directory** where you run the command.\n  * The directory will be created if it doesn't exist.\n  * The command will fail if the specified path exists but is not a directory.\n* `-f`, `--force`: Overwrite existing files when a `File` or `Moved File` action targets a path that already exists as a file. Without this flag, existing files will be skipped. This flag does not allow replacing a directory with a file. It does not currently affect `Append File` or `Prepend File` actions beyond their standard behavior (they will operate on existing files or create new ones).\n* `-h`, `--help`: Print help information.\n* `-V`, `--version`: Print version information.\n\n## Input Markdown Format\n\nThe processor identifies actions based on specific header patterns.\n\n### Action Headers\n\nThe following header formats are recognized:\n\n**1. `File` Actions (Create/Overwrite):**\n\nThese headers must be immediately followed by a fenced code block (e.g., `````, ```` ``` ````). The content of the code block becomes the content of the file.\n\n* **Markdown Headers:**\n  * `## File: path/to/your/file.txt`\n  * `**File: path/to/your/file.txt**`\n* **Backtick Path Only:** (Implies `File` action)\n  * `` `path/to/your/file.txt` ``\n  * `1.`path/to/your/file.txt`` (Numbered list item)\n  * `**`path/to/your/file.txt`**`\n  * `##`path/to/your/file.txt``\n\n**Example (Standard Header):**\n\n````markdown\n## File: src/main.rs\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n````\n\n**2. `Append File` Actions:**\n\nThese headers must be immediately followed by a fenced code block. The content of the code block will be appended to the specified file. If the file does not exist, it will be created with the content.\n\n* **Markdown Headers:**\n  * `## Append File: path/to/your/file.txt`\n  * `**Append File: path/to/your/file.txt**`\n\n**Example (Append Header):**\n\n````markdown\n## Append File: logs/app.log\n\n```\n[INFO] Application started.\n```\n````\n\n**3. `Prepend File` Actions:**\n\nThese headers must be immediately followed by a fenced code block. The content of the code block will be prepended to the specified file. If the file does not exist, it will be created with the content.\n\n* **Markdown Headers:**\n  * `## Prepend File: path/to/your/file.txt`\n  * `**Prepend File: path/to/your/file.txt**`\n\n**Example (Prepend Header):**\n\n````markdown\n## Prepend File: config.ini\n\n```ini\n; Generated by Strux\n```\n````\n\n**4. `Deleted File` Actions:**\n\nThese headers define files to be deleted. They should *not* be followed by a code block unless using the special case below.\n\n* **Standalone Headers:**\n  * `## Deleted File: path/to/old/file.log`\n  * `**Deleted File: path/to/old/file.log**`\n\n* **Special Case (Path in Block):** A `## Deleted File:` header *without* a path, immediately followed by a code block containing *only* the path to delete on its first line.\n\n````markdown\n## Deleted File:\n\n```text\npath/inside/block_to_delete.tmp\n```\n````\n\n**5. `Moved File` Actions:**\n\nThese headers define files to be moved. They should *not* be followed by a code block. The keyword \" to \" (case-sensitive, with spaces) separates the source and destination paths.\n\n* **Standalone Headers:**\n  * `## Moved File: old/path/file.txt to new/path/file.txt`\n  * `**Moved File: old/path/file.txt to new/path/file.txt**`\n* If a path segment itself contains \" to \", that segment must be enclosed in backticks:\n  * `## Moved File: \\`archive/file with to in name.log\\` to archive/renamed_file.log`\n  * `## Moved File: old/path.txt to \\`new path with to in name.txt\\``\n\n**Example (Moved File):**\n````markdown\n## Moved File: temp/report.docx to final/official_report.docx\n````\n\n**6. Internal Comment Headers (Inside Code Blocks for `File`, `Append File`, `Prepend File` actions):**\n\nThese headers can appear on the *first line* inside a code block to define the file path for a `File`, `Append File`, or `Prepend File` action.\n*Supported types: `File` (e.g., `// File: path/to/file.ext`). Support for `Append File` and `Prepend File` in this format may be added in the future.*\n\n* `// File: path/to/file.ext`: The header line itself is **excluded** from the file content. Supports paths in backticks (`// File:\\`path with spaces.txt\\``).\n\n    ```javascript\n    // File: utils/helper.js\n    function greet(name) {\n      console.log(`Hello, ${name}!`);\n    }\n    module.exports = { greet };\n    ```\n\n* `// path/to/file.ext`: The header line is **included** in the file content.\n\n    ```javascript\n    // scripts/run_analysis.js\n    console.log(\"Running analysis...\")\n    ```\n\n    *Heuristics apply to avoid misinterpreting comments as paths.*\n\n**7. Wrapped Headers:**\n\nA header can be placed inside a ` ```markdown ` or ` ```md ` block.\n* For `File`, `Append File`, or `Prepend File` actions, it applies to the *next adjacent* code block.\n* For `Deleted File` or `Moved File` actions, it's a standalone action.\n\n* **Create Example:**\n\n    ````markdown\n    ```markdown\n    ## File: complex_config.yaml\n    ```\n\n    ```yaml\n    # This is the actual content\n    settings:\n      feature_a: true\n    ```\n    ````\n* **Append Example:**\n\n    ````markdown\n    ```markdown\n    ## Append File: notes.txt\n    ```\n\n    ```\n    Another note.\n    ```\n    ````\n\n* **Delete Example:**\n\n    ````markdown\n    ```markdown\n    **Deleted File: legacy_script.sh**\n    ```\n    *(No following code block needed for delete)*\n    ````\n\n* **Move Example:**\n    ````markdown\n    ```markdown\n    ## Moved File: staging/data.csv to processed/data.csv\n    ```\n    *(No following code block needed for move)*\n    ````\n\n### Path Handling and Safety\n\n* Paths specified in headers are treated as relative to the `--output-dir`.\n* Parent directories are created automatically as needed for `File`, `Append File`, `Prepend File` actions and for the destination of `Moved File` actions.\n* **Safety:** The tool prevents writing or moving files outside the resolved base output directory. Paths containing `..` that would escape the base directory will cause the action to fail safely.\n* Paths containing invalid components (like `//` or trailing `/`) will be skipped.\n\n### Content Handling (for `File`, `Append File`, `Prepend File` actions)\n\n* The *entire* content within the fenced code block (excluding the fences themselves and certain internal headers) is written to the file (or appended/prepended).\n* A trailing newline (`\\n`) is added to this content chunk if it doesn't already end with one.\n\n## Examples\n\n**Input (`example.md`):**\n\n````markdown\n# Example Project Structure\n\n## File: src/main.py\n```python\n# Main application script\nimport utils\ndef main(): utils.helper()\nif __name__ == \"__main__\": main()\n```\n\n## File: src/utils.py\n```python\n# Utility functions\ndef helper(): print(\"Helper function called.\")\n```\n\n## File: temp/draft.txt\n```\nThis is a draft file that will be moved.\n```\n\n**Deleted File: old_data.csv**\n\n`README.md`\n```markdown\n# My Project\nGenerated by Strux.\n```\n\n## Moved File: temp/draft.txt to docs/final_draft.txt\n\n## Append File: README.md\n```\nThis content will be appended.\n```\n\n```md\n## Deleted File: temp/to_delete.log\n```\n\n```markdown\n// File: .gitignore\n*.pyc\n__pycache__/\n```\n````\n\n**Command:**\n\n```bash\n# Assuming you run this in /home/user/projects/\nstrux -o my_project example.md\n# Output will be in /home/user/projects/my_project\n```\n\n**Result (`my_project` directory):**\n\n```plaintext\nmy_project/\n├── .gitignore\n├── README.md  # Content: \"# My Project\\nGenerated by Strux.\\nThis content will be appended.\\n\"\n├── docs/\n│   └── final_draft.txt  # Moved from temp/draft.txt\n└── src/\n    ├── main.py\n    └── utils.py\n```\n\n* `my_project/src/main.py` and `my_project/src/utils.py` contain their Python code.\n* `my_project/README.md` contains its original content plus the appended text.\n* `my_project/.gitignore` contains its content.\n* `my_project/docs/final_draft.txt` contains \"This is a draft file that will be moved.\\n\" (moved from `my_project/temp/draft.txt`).\n* The original `my_project/temp/draft.txt` is gone as it was moved.\n* Any pre-existing `my_project/old_data.csv` or `my_project/temp/to_delete.log` (if they existed in the output directory before the run) would be deleted.\n\n## Development\n\n### Prerequisites\n\n* Rust & Cargo ([https://rustup.rs/](https://rustup.rs/))\n* `pre-commit` ([https://pre-commit.com/](https://pre-commit.com/))\n\n### Setup\n\n1. Clone the repository.\n2. Install pre-commit hooks: `pre-commit install`\n\n### Building\n\n```bash\ncargo build         # Development build\ncargo build --release # Release build\n```\n\n### Testing\n\n```bash\ncargo test          # Run all tests\n```\n\n### Pre-commit Hooks\n\nThis project uses `pre-commit` for automated code quality checks (formatting, linting, tests) before each commit.\n\n## Commit Messages\n\nThis project follows the [Conventional Commits specification](https://www.conventionalcommits.org/). See [COMMIT.md](COMMIT.md) for details.\n";

#[test]
fn test_process_readme_md_as_input() {
    let temp_dir = setup_temp_dir();

    // Construct the input for strux: a header defining README.md,
    // with the actual README content inside a ```md block.
    // trim_end_matches ensures that the content fed to strux has no trailing newlines,
    // so strux's ensure_trailing_newline logic will add exactly one.
    let content_for_strux_block = ACTUAL_README_CONTENT.trim_end_matches(['\n', '\r']);

    let strux_input_md = format!(
        "## File: README.md\n```md\n{}\n```\n",
        content_for_strux_block
    );

    let (summary, _) = run_processor(&strux_input_md, &temp_dir, false)
        .expect("Processing README.md input failed");

    // Assert that the generated README.md exists
    let generated_readme_path = temp_dir.child("README.md");
    generated_readme_path.assert(predicate::path::is_file());

    // Prepare the expected content: should be the original content,
    // but normalized to have exactly one trailing newline, matching strux's output behavior.
    let mut expected_content_str = content_for_strux_block.to_string();
    if !content_for_strux_block.is_empty() {
        expected_content_str.push('\n');
    }

    generated_readme_path.assert(predicate::str::diff(expected_content_str));

    // Assert the summary
    assert_summary(
        &summary, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    );
}
